<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>An√°lisis</title>
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <link rel="alternate icon" href="favicon.ico">
    
    <!-- Fuentes -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Syne:wght@400;600;700;800&family=DM+Sans:wght@400;500;700&display=swap" rel="stylesheet">

	<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- CSS -->
    <link rel="stylesheet" href="css/styles-common.css">
    <link rel="stylesheet" href="css/styles-tournaments.css">
    <link rel="stylesheet" href="css/styles-registro.css">
	<link rel="stylesheet" href="css/bottom-nav.css">
	<link rel="stylesheet" href="css/comparativa_torneos.css">
    
    <!-- Chart.js para gr√°ficos -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <!-- Verificar sesi√≥n -->
    <script>
        if (!sessionStorage.getItem('xisco_session_active')) {
            window.location.href = 'index.html';
        }
    </script>
</head>
<body>
    


	<!-- ============================================ -->
<!-- COMPARATIVA DE CIRCUITOS - VERSI√ìN CORREGIDA V3 -->
<!-- Con detecci√≥n mejorada de victorias, m√©tricas Y POSICIONES -->
<!-- ============================================ -->

<script>
// ============================================
// VARIABLES GLOBALES PARA COMPARATIVA
// ============================================

let circuitComparisonChart = null;
let selectedCircuits = new Set();
const circuitColors = [
    '#3b82f6', // Azul
    '#ef4444', // Rojo
    '#10b981', // Verde
    '#f59e0b', // Amarillo
    '#8b5cf6', // P√∫rpura
    '#ec4899', // Rosa
    '#14b8a6', // Turquesa
    '#f97316', // Naranja
    '#6366f1', // √çndigo
    '#84cc16', // Lima
];

// ============================================
// FUNCI√ìN PARA OBTENER NOMBRE REAL DEL CIRCUITO
// ============================================

function getCircuitName(circuitId) {
    if (!circuitId) return 'Sin circuito';
    
    // Si es un ID (empieza con "circuit_"), buscar el nombre real
    if (circuitId.startsWith('circuit_')) {
        // Buscar en la lista de circuitos
        if (matchesData.circuits && Array.isArray(matchesData.circuits)) {
            const circuit = matchesData.circuits.find(c => c.id === circuitId);
            if (circuit && circuit.name) {
                return circuit.name;
            }
        }
        
        // Si no se encuentra, intentar obtener de los torneos
        const tournament = matchesData.tournaments.find(t => t.circuit === circuitId);
        if (tournament && tournament.circuitName) {
            return tournament.circuitName;
        }
        
        // Si a√∫n no se encuentra, retornar un nombre m√°s legible
        return circuitId.replace('circuit_', 'Circuito #').substring(0, 20);
    }
    
    // Si no es un ID, retornar tal cual (es el nombre)
    return circuitId;
}

// ============================================
// FUNCI√ìN PARA DETECTAR SI ES VICTORIA
// ============================================

function isVictory(result) {
    if (!result) return false;
    
    // Normalizar el resultado
    const normalized = String(result).trim().toLowerCase();
    
    // Casos de victoria
    const victoryPatterns = [
        '1¬∫',
        '1¬∞',
        '1',
        'primero',
        'ganador',
        'campe√≥n',
        'campeon',
        'victoria',
        'winner',
        'first'
    ];
    
    // Verificar si coincide con alg√∫n patr√≥n
    for (const pattern of victoryPatterns) {
        if (normalized === pattern || normalized === pattern.toLowerCase()) {
            return true;
        }
    }
    
    // Verificar si empieza con "1" seguido de caracteres no num√©ricos
    if (/^1[^\d]/.test(normalized)) {
        return true;
    }
    
    return false;
}

// ============================================
// FUNCI√ìN PARA EXTRAER POSICI√ìN NUM√âRICA
// ============================================

function extractPosition(result) {
    if (!result) return null;
    
    const str = String(result).trim();
    
    // Intentar extraer n√∫mero al inicio
    const match = str.match(/^(\d+)/);
    if (match) {
        return parseInt(match[1]);
    }
    
    // Casos especiales
    const specialCases = {
        'primero': 1,
        'segundo': 2,
        'tercero': 3,
        'cuarto': 4,
        'quinto': 5,
        'first': 1,
        'second': 2,
        'third': 3
    };
    
    const normalized = str.toLowerCase();
    if (specialCases[normalized]) {
        return specialCases[normalized];
    }
    
    return null;
}

// ============================================
// ‚úÖ NUEVA FUNCI√ìN: DETECTAR POSICI√ìN (MEJORADA)
// Prioriza Campe√≥n > Subcampe√≥n > Semifinales > N√∫meros
// ============================================

function detectTournamentPosition(result, position) {
    let detectedPosition = '-';
    let positionNumber = null;
    
    // Si tiene position directamente, tiene prioridad
    if (position) {
        positionNumber = parseInt(position);
        detectedPosition = `${positionNumber}¬∫`;
        return { position: detectedPosition, positionNumber };
    }
    
    if (!result) {
        return { position: '-', positionNumber: null };
    }
    
    const resultLower = result.toLowerCase().trim();
    
    // ORDEN IMPORTA - De m√°s espec√≠fico a menos
    
    // 1. Subcampe√≥n / Finalista / 2¬∫
    if (resultLower.includes('subcampe√≥n') || resultLower.includes('subcampeon') || 
        resultLower === 'subcampeon' || resultLower === 'subcampe√≥n' ||
        resultLower.includes('finalista') || resultLower === '2¬∫' || 
        resultLower === '2' || resultLower === '2¬∫ puesto' || resultLower === 'segundo') {
        detectedPosition = '2¬∫';
        positionNumber = 2;
    }
    // 2. Semifinales (puede ser 3¬∫ o 4¬∫)
    else if (resultLower.includes('semifinal') || resultLower.includes('semi-final') ||
             resultLower === 'semifinalista' || resultLower === 'semifinales') {
        const match = result.match(/(\d+)/);
        if (match) {
            positionNumber = parseInt(match[1]);
            detectedPosition = `${positionNumber}¬∫`;
        } else {
            detectedPosition = '3¬∫-4¬∫';
            positionNumber = 3;
        }
    }
    // 3. Tercero
    else if (resultLower === '3' || resultLower === '3¬∫' || resultLower === '3¬∫ puesto' || 
             resultLower === 'tercero' || resultLower === 'tercer puesto') {
        detectedPosition = '3¬∫';
        positionNumber = 3;
    }
    // 4. Cuarto
    else if (resultLower === '4' || resultLower === '4¬∫' || resultLower === '4¬∫ puesto' || 
             resultLower === 'cuarto' || resultLower === 'cuarto puesto') {
        detectedPosition = '4¬∫';
        positionNumber = 4;
    }
    // 5. Campe√≥n / Ganador / 1¬∫
    else if (resultLower.includes('campe√≥n') || resultLower.includes('campeon') || 
             resultLower === 'campeon' || resultLower === 'campe√≥n' ||
             resultLower === '1' || resultLower === '1¬∫' || resultLower === 'primero' ||
             resultLower === 'ganador' || resultLower === 'winner') {
        detectedPosition = '1¬∫';
        positionNumber = 1;
    }
    // 6. Intentar extraer cualquier n√∫mero
    else {
        const match = result.match(/(\d+)/);
        if (match) {
            positionNumber = parseInt(match[1]);
            detectedPosition = `${positionNumber}¬∫`;
        } else {
            detectedPosition = result;
        }
    }
    
    return { position: detectedPosition, positionNumber };
}

// ============================================
// INICIALIZAR COMPARATIVA DE CIRCUITOS
// ============================================

function initCircuitComparison() {
    console.log('üîÑ Inicializando comparativa de circuitos...');
    
    // Obtener circuitos √∫nicos de los torneos
    const circuits = getCircuitsFromTournaments();
    
    console.log('üìä Circuitos encontrados:', circuits.length);
    
    if (circuits.length === 0) {
        document.getElementById('circuitCheckboxes').style.display = 'none';
        document.getElementById('noCircuitsMessage').style.display = 'block';
        return;
    }
    
    document.getElementById('circuitCheckboxes').style.display = 'grid';
    document.getElementById('noCircuitsMessage').style.display = 'none';
    
    // Crear checkboxes
    renderCircuitCheckboxes(circuits);
    
    // Seleccionar todos por defecto (m√°ximo 5)
    const circuitsToSelect = circuits.slice(0, 5);
    circuitsToSelect.forEach(circuit => selectedCircuits.add(circuit.id));
    
    // Actualizar UI
    updateCheckboxStates();
    
    // Renderizar gr√°fica
    updateCircuitComparison();
}

// ============================================
// OBTENER CIRCUITOS DE TORNEOS
// ============================================

function getCircuitsFromTournaments() {
    const circuitMap = new Map();
    
    matchesData.tournaments.forEach(tournament => {
        if (tournament.circuit && tournament.circuit.trim() !== '') {
            const circuitId = tournament.circuit.trim();
            const circuitName = getCircuitName(circuitId);
            
            if (!circuitMap.has(circuitId)) {
                circuitMap.set(circuitId, {
                    id: circuitId,
                    name: circuitName,
                    count: 0,
                    tournaments: []
                });
            }
            
            const circuit = circuitMap.get(circuitId);
            circuit.count++;
            circuit.tournaments.push(tournament);
        }
    });
    
    // Convertir a array y ordenar por cantidad de torneos
    return Array.from(circuitMap.values())
        .sort((a, b) => b.count - a.count);
}

// ============================================
// RENDERIZAR CHECKBOXES
// ============================================

function renderCircuitCheckboxes(circuits) {
    const container = document.getElementById('circuitCheckboxes');
    
    container.innerHTML = circuits.map((circuit, index) => `
        <div class="circuit-checkbox ${selectedCircuits.has(circuit.id) ? 'selected' : ''}" 
             onclick="toggleCircuitSelection('${escapeHtml(circuit.id)}')">
            <input 
                type="checkbox" 
                id="circuit_${index}"
                ${selectedCircuits.has(circuit.id) ? 'checked' : ''}
                onchange="toggleCircuitSelection('${escapeHtml(circuit.id)}')"
                onclick="event.stopPropagation()">
            <label for="circuit_${index}">${escapeHtml(circuit.name)}</label>
            <span class="circuit-count">${circuit.count}</span>
        </div>
    `).join('');
}

// ============================================
// TOGGLE SELECCI√ìN DE CIRCUITO
// ============================================

function toggleCircuitSelection(circuitId) {
    if (selectedCircuits.has(circuitId)) {
        selectedCircuits.delete(circuitId);
    } else {
        selectedCircuits.add(circuitId);
    }
    
    updateCheckboxStates();
    updateCircuitComparison();
}

// ============================================
// ACTUALIZAR ESTADOS DE CHECKBOXES
// ============================================

function updateCheckboxStates() {
    const circuits = getCircuitsFromTournaments();
    const checkboxes = document.querySelectorAll('.circuit-checkbox');
    
    checkboxes.forEach((checkbox, index) => {
        const circuit = circuits[index];
        if (!circuit) return;
        
        const input = checkbox.querySelector('input[type="checkbox"]');
        
        if (selectedCircuits.has(circuit.id)) {
            checkbox.classList.add('selected');
            input.checked = true;
        } else {
            checkbox.classList.remove('selected');
            input.checked = false;
        }
    });
}

// ============================================
// SELECCIONAR TODOS LOS CIRCUITOS
// ============================================

function selectAllCircuits() {
    const circuits = getCircuitsFromTournaments();
    selectedCircuits.clear();
    circuits.forEach(circuit => selectedCircuits.add(circuit.id));
    updateCheckboxStates();
    updateCircuitComparison();
}

// ============================================
// LIMPIAR SELECCI√ìN
// ============================================

function clearCircuitSelection() {
    selectedCircuits.clear();
    updateCheckboxStates();
    updateCircuitComparison();
}

// ============================================
// ACTUALIZAR COMPARATIVA
// ============================================

function updateCircuitComparison() {
    if (selectedCircuits.size === 0) {
        destroyCircuitChart();
        document.getElementById('circuitComparisonTableBody').innerHTML = `
            <tr>
                <td colspan="7" style="text-align: center; color: #86868b; padding: 40px;">
                    Selecciona al menos un circuito para ver la comparativa
                </td>
            </tr>
        `;
        return;
    }
    
    const metric = document.getElementById('comparisonMetric').value;
    const circuitsData = calculateCircuitStats();
    
    console.log('üìä Datos de circuitos calculados:', circuitsData);
    
    renderCircuitChart(circuitsData, metric);
    renderCircuitTable(circuitsData);
}

// ============================================
// ‚úÖ CALCULAR ESTAD√çSTICAS DE CIRCUITOS (FIXED)
// Ahora usa detectTournamentPosition para mejor detecci√≥n
// ============================================

function calculateCircuitStats() {
    const stats = [];
    const circuits = getCircuitsFromTournaments();
    
    selectedCircuits.forEach(circuitId => {
        const circuit = circuits.find(c => c.id === circuitId);
        if (!circuit) return;
        
        const tournaments = matchesData.tournaments.filter(t => t.circuit === circuitId);
        
        if (tournaments.length === 0) return;
        
        // Calcular estad√≠sticas
        const totalTournaments = tournaments.length;
        
        // Contar victorias con la nueva funci√≥n mejorada
        const totalWins = tournaments.filter(t => isVictory(t.result)).length;
        
        console.log(`üèÜ ${circuit.name}: ${totalWins} victorias de ${totalTournaments} torneos`);
        
        const winRate = totalTournaments > 0 ? (totalWins / totalTournaments * 100) : 0;
        
        // Calcular total de partidas
        let totalMatches = 0;
        let totalMatchWins = 0;
        
        tournaments.forEach(t => {
            if (t.stats) {
                // Intentar diferentes nombres de campos
                const wins = t.stats.victorias || t.stats.wins || t.stats.gamesWon || 0;
                const losses = t.stats.derrotas || t.stats.losses || t.stats.gamesLost || 0;
                
                totalMatches += wins + losses;
                totalMatchWins += wins;
            }
        });
        
        // ‚úÖ FIXED: Calcular posici√≥n promedio y mejor posici√≥n con detecci√≥n mejorada
        let bestPositionNumber = Infinity;
        let bestPositionText = '-';
        const validPositions = [];
        
        tournaments.forEach(tournament => {
            const { position, positionNumber } = detectTournamentPosition(
                tournament.result, 
                tournament.position
            );
            
            if (positionNumber !== null && positionNumber > 0) {
                validPositions.push(positionNumber);
                
                if (positionNumber < bestPositionNumber) {
                    bestPositionNumber = positionNumber;
                    bestPositionText = position;
                }
            }
        });
        
        const avgPosition = validPositions.length > 0 
            ? validPositions.reduce((a, b) => a + b, 0) / validPositions.length 
            : 0;
        
        const bestPosition = bestPositionNumber !== Infinity ? bestPositionNumber : 0;
        
        // √öltima participaci√≥n
        const sortedTournaments = tournaments.sort((a, b) => new Date(b.date) - new Date(a.date));
        const lastDate = sortedTournaments[0]?.date || '';
        
        const circuitStats = {
            id: circuitId,
            name: circuit.name,
            tournaments: totalTournaments,
            wins: totalWins,
            winRate: winRate,
            avgPosition: avgPosition,
            bestPosition: bestPosition,
            totalMatches: totalMatches,
            totalMatchWins: totalMatchWins,
            lastDate: lastDate
        };
        
        console.log('üìä Estad√≠sticas calculadas:', circuitStats);
        
        stats.push(circuitStats);
    });
    
    return stats;
}

// ============================================
// RENDERIZAR GR√ÅFICA DE CIRCUITOS (L√çNEAS)
// ============================================

function renderCircuitChart(circuitsData, metric) {
    const ctx = document.getElementById('circuitComparisonChart');
    
    if (!ctx) {
        console.error('Canvas no encontrado');
        return;
    }
    
    // Destruir gr√°fica anterior
    destroyCircuitChart();
    
    // Preparar datos seg√∫n la m√©trica
    let labels = circuitsData.map(c => c.name);
    let data, label, yAxisLabel;
    
    switch(metric) {
        case 'tournaments':
            data = circuitsData.map(c => c.tournaments);
            label = 'N√∫mero de Torneos';
            yAxisLabel = 'Torneos';
            break;
        case 'winRate':
            data = circuitsData.map(c => parseFloat(c.winRate.toFixed(1)));
            label = 'Tasa de Victoria (%)';
            yAxisLabel = 'Porcentaje (%)';
            break;
        case 'avgPosition':
            data = circuitsData.map(c => c.avgPosition > 0 ? parseFloat(c.avgPosition.toFixed(1)) : 0);
            label = 'Posici√≥n Promedio';
            yAxisLabel = 'Posici√≥n';
            break;
        case 'totalMatches':
            data = circuitsData.map(c => c.totalMatches);
            label = 'Total de Partidas';
            yAxisLabel = 'Partidas';
            break;
        case 'totalWins':
            data = circuitsData.map(c => c.wins);
            label = 'Total de Victorias';
            yAxisLabel = 'Victorias en Torneos';
            break;
        default:
            data = circuitsData.map(c => c.tournaments);
            label = 'N√∫mero de Torneos';
            yAxisLabel = 'Torneos';
    }
    
    console.log('üìä Renderizando gr√°fica:', { metric, label, data });
    
    // Si hay m√∫ltiples circuitos, crear l√≠nea conectada
    if (circuitsData.length > 1) {
        // Crear una sola l√≠nea que conecta todos los puntos
        const mainDataset = {
            label: label,
            data: data,
            borderColor: '#94a3b8',
            backgroundColor: 'transparent',
            borderWidth: 2,
            borderDash: [5, 5],
            pointRadius: 0,
            tension: 0.4,
            fill: false
        };
        
        // Crear puntos individuales de colores
        const pointDatasets = circuitsData.map((circuit, index) => {
            const color = circuitColors[index % circuitColors.length];
            
            return {
                label: circuit.name,
                data: data.map((_, i) => i === index ? data[i] : null),
                borderColor: color,
                backgroundColor: color,
                borderWidth: 3,
                pointRadius: 8,
                pointHoverRadius: 10,
                pointBackgroundColor: color,
                pointBorderColor: '#fff',
                pointBorderWidth: 3,
                tension: 0.4,
                fill: false,
                showLine: false
            };
        });
        
        // Crear gr√°fica con l√≠nea base y puntos de colores
        circuitComparisonChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: labels,
                datasets: [mainDataset, ...pointDatasets]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: {
                    mode: 'point',
                    intersect: true
                },
                plugins: {
                    legend: {
                        display: true,
                        position: 'top',
                        labels: {
                            font: {
                                family: '-apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif',
                                size: 12,
                                weight: '500'
                            },
                            padding: 16,
                            usePointStyle: true,
                            pointStyle: 'circle',
                            filter: function(item, chart) {
                                return item.text !== label;
                            }
                        }
                    },
                    tooltip: {
                        backgroundColor: 'rgba(0, 0, 0, 0.8)',
                        padding: 12,
                        titleFont: {
                            size: 14,
                            weight: '600'
                        },
                        bodyFont: {
                            size: 13
                        },
                        borderColor: 'rgba(255, 255, 255, 0.2)',
                        borderWidth: 1,
                        displayColors: true,
                        callbacks: {
                            label: function(context) {
                                if (context.dataset.label === label) return null;
                                
                                let labelText = context.dataset.label || '';
                                if (labelText) {
                                    labelText += ': ';
                                }
                                labelText += context.parsed.y;
                                if (metric === 'winRate') {
                                    labelText += '%';
                                } else if (metric === 'avgPosition') {
                                    labelText += '¬∫';
                                }
                                return labelText;
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        grid: {
                            color: 'rgba(0, 0, 0, 0.05)',
                            drawBorder: false
                        },
                        title: {
                            display: true,
                            text: yAxisLabel,
                            font: {
                                size: 13,
                                weight: '600'
                            }
                        },
                        ticks: {
                            font: {
                                size: 12
                            },
                            padding: 8,
                            callback: function(value) {
                                if (metric === 'winRate') {
                                    return value + '%';
                                } else if (metric === 'avgPosition') {
                                    return value + '¬∫';
                                }
                                return value;
                            }
                        }
                    },
                    x: {
                        grid: {
                            display: false
                        },
                        ticks: {
                            font: {
                                size: 12,
                                weight: '500'
                            },
                            padding: 8
                        }
                    }
                }
            }
        });
    } else {
        // Para un solo circuito, usar gr√°fica de barras simple
        circuitComparisonChart = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: labels,
                datasets: [{
                    label: label,
                    data: data,
                    backgroundColor: circuitColors[0] + '40',
                    borderColor: circuitColors[0],
                    borderWidth: 2,
                    borderRadius: 8
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        backgroundColor: 'rgba(0, 0, 0, 0.8)',
                        padding: 12,
                        callbacks: {
                            label: function(context) {
                                let labelText = label + ': ' + context.parsed.y;
                                if (metric === 'winRate') {
                                    labelText += '%';
                                } else if (metric === 'avgPosition') {
                                    labelText += '¬∫';
                                }
                                return labelText;
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        grid: {
                            color: 'rgba(0, 0, 0, 0.05)'
                        },
                        title: {
                            display: true,
                            text: yAxisLabel
                        },
                        ticks: {
                            callback: function(value) {
                                if (metric === 'winRate') {
                                    return value + '%';
                                } else if (metric === 'avgPosition') {
                                    return value + '¬∫';
                                }
                                return value;
                            }
                        }
                    }
                }
            }
        });
    }
}

// ============================================
// DESTRUIR GR√ÅFICA
// ============================================

function destroyCircuitChart() {
    if (circuitComparisonChart) {
        circuitComparisonChart.destroy();
        circuitComparisonChart = null;
    }
}

// ============================================
// RENDERIZAR TABLA COMPARATIVA
// ============================================

function renderCircuitTable(circuitsData) {
    const tbody = document.getElementById('circuitComparisonTableBody');
    
    if (circuitsData.length === 0) {
        tbody.innerHTML = `
            <tr>
                <td colspan="7" style="text-align: center; color: #86868b; padding: 40px;">
                    No hay datos para mostrar
                </td>
            </tr>
        `;
        return;
    }
    
    tbody.innerHTML = circuitsData.map((circuit, index) => {
        const color = circuitColors[index % circuitColors.length];
        const winRateClass = circuit.winRate >= 50 ? 'positive' : circuit.winRate >= 30 ? 'neutral' : 'negative';
        const positionClass = circuit.avgPosition <= 3 ? 'positive' : circuit.avgPosition <= 8 ? 'neutral' : 'negative';
        
        return `
            <tr>
                <td>
                    <div class="circuit-name">
                        <div class="circuit-color" style="background-color: ${color};"></div>
                        ${escapeHtml(circuit.name)}
                    </div>
                </td>
                <td class="metric-value">${circuit.tournaments}</td>
                <td class="metric-value">${circuit.wins}</td>
                <td class="metric-value ${winRateClass}">${circuit.winRate.toFixed(1)}%</td>
                <td class="metric-value ${positionClass}">
                    ${circuit.avgPosition > 0 ? circuit.avgPosition.toFixed(1) + '¬∫' : '-'}
                </td>
                <td class="metric-value positive">
                    ${circuit.bestPosition > 0 ? circuit.bestPosition + '¬∫' : '-'}
                </td>
                <td>${circuit.lastDate ? new Date(circuit.lastDate).toLocaleDateString('es-ES') : '-'}</td>
            </tr>
        `;
    }).join('');
}

// ============================================
// FUNCI√ìN AUXILIAR: ESCAPE HTML
// ============================================

function escapeHtml(text) {
    if (!text) return '';
    const map = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#039;'
    };
    return String(text).replace(/[&<>"']/g, m => map[m]);
}

// ============================================
// INICIALIZAR AL CARGAR LA P√ÅGINA
// ============================================

document.addEventListener('DOMContentLoaded', () => {
    setTimeout(() => {
        if (typeof initCircuitComparison === 'function') {
            initCircuitComparison();
        }
    }, 500);
});

// Tambi√©n actualizar cuando cambien los datos
function updateCircuitComparisonIfVisible() {
    const comparisonChart = document.getElementById('circuitComparisonChart');
    if (comparisonChart && comparisonChart.offsetParent !== null) {
        initCircuitComparison();
    }
}

console.log('‚úÖ Comparativa de circuitos v3 - FIX APLICADO: Detecci√≥n mejorada de posiciones (Campe√≥n > Subcampe√≥n > Semifinales > N√∫meros)');
</script>
 <div class="container">


   <!-- Header -->
<div class="page-header">
    <div class="header-content-wrapper">
        <div class="header-text">
            <h1>An√°lisis</h1>
            <p>Gr√°ficas comparativas de rendiento en torneos</p>
        </div>
        <div class="header-image">
            <img src="/pool/images/banner.png" alt="Xisco">
        </div>
    </div>
</div>
        <!-- Secci√≥n de Exportaci√≥n y Sincronizaci√≥n -->
        <div class="analytics-section">
          <div class="section-header" id="analisis">
         
          </div>
          <div class="charts-grid">
            <!-- Gr√°fico: Resultados por A√±o -->
            <div class="chart-card">
              <div class="chart-header">
                <h3 class="chart-title">Resultados por A√±o</h3>
                <p class="chart-description">Evoluci√≥n de tus logros en el tiempo</p>
              </div>
              <div class="chart-container2">
                <canvas id="yearResultsChart"></canvas>
              </div>
            </div>
            <!-- Gr√°fico: Rendimiento por Material -->
            <div class="chart-card">
              <div class="chart-header">
                <h3 class="chart-title">Rendimiento por Taco</h3>
                <p class="chart-description">¬øQu√© material te da mejores resultados?</p>
              </div>
              <div class="chart-container2">
                <canvas id="materialPerformanceChart"></canvas>
              </div>
            </div>
            <!-- Gr√°fico: Evoluci√≥n Temporal -->
            <div class="chart-card chart-card-wide">
              <div class="chart-header">
                <h3 class="chart-title">Evoluci√≥n Temporal</h3>
                <p class="chart-description">L√≠nea de tiempo de tus torneos</p>
              </div>
              <div class="chart-container1">
                <canvas id="timelineChart"></canvas>
              </div>
            </div>
          </div>
        </div>
	 
<div class="card">
    <div class="card-header">
        <h2>Comparativa de Circuitos</h2>

    </div>
    
    <div class="card-body">
        <!-- Selector de circuitos -->
        <div class="circuit-selector-container">
            <div class="selector-header">
                <span class="selector-label">Selecciona circuitos para comparar:</span>
                <button class="btn-secondary btn-small" onclick="selectAllCircuits()">
                    Seleccionar todos
                </button>
                <button class="btn-secondary btn-small" onclick="clearCircuitSelection()">
                    Limpiar selecci√≥n
                </button>
            </div>
            
            <div id="circuitCheckboxes" class="circuit-checkboxes">
                <!-- Se llenar√° din√°micamente con JavaScript -->
            </div>
            
            <div class="no-circuits" id="noCircuitsMessage" style="display: none;">
                <p>‚ö†Ô∏è No hay circuitos para comparar. A√±ade circuitos a tus torneos primero.</p>
            </div>
        </div>
        
        <!-- Selector de m√©trica -->
        <div class="metric-selector">
            <label for="comparisonMetric">Comparar por:</label>
            <select id="comparisonMetric" onchange="updateCircuitComparison()">
                <option value="tournaments">N√∫mero de torneos</option>
                <option value="winRate">Tasa de victoria (%)</option>
                <option value="avgPosition">Posici√≥n promedio</option>
                <option value="totalMatches">Total de partidas</option>
                <option value="totalWins">Total de victorias</option>
            </select>
        </div>
        
        <!-- Gr√°fica -->
        <div class="chart-card">
            <canvas id="circuitComparisonChart"></canvas>
        </div>
        
        <!-- Tabla comparativa -->
        <div class="chart-card comparison-table-container">
            <h3>Detalles por circuito</h3>
            <div class="table-responsive">
                <table id="circuitComparisonTable" class="comparison-table">
                    <thead>
                        <tr>
                            <th>Circuito</th>
                            <th>Torneos</th>
                            <th>Victorias</th>
                            <th>% Victoria</th>
                            <th>Pos. Media</th>
                            <th>Mejor Pos.</th>
                            <th>√öltima participaci√≥n</th>
                        </tr>
                    </thead>
                    <tbody id="circuitComparisonTableBody">
                        <!-- Se llenar√° din√°micamente -->
                    </tbody>
                </table>
            </div>
        </div>
    </div>
</div>


		<!-- ============================================ -->
<!-- COMPARATIVA DE CIRCUITOS - VERSI√ìN CORREGIDA V2 -->
<!-- Con detecci√≥n mejorada de victorias y m√©tricas -->
<!-- ============================================ -->

<script>
// ============================================
// VARIABLES GLOBALES PARA COMPARATIVA
// ============================================

let circuitComparisonChart = null;
let selectedCircuits = new Set();
const circuitColors = [
    '#3b82f6', // Azul
    '#ef4444', // Rojo
    '#10b981', // Verde
    '#f59e0b', // Amarillo
    '#8b5cf6', // P√∫rpura
    '#ec4899', // Rosa
    '#14b8a6', // Turquesa
    '#f97316', // Naranja
    '#6366f1', // √çndigo
    '#84cc16', // Lima
];

// ============================================
// FUNCI√ìN PARA OBTENER NOMBRE REAL DEL CIRCUITO
// ============================================

function getCircuitName(circuitId) {
    if (!circuitId) return 'Sin circuito';
    
    // Si es un ID (empieza con "circuit_"), buscar el nombre real
    if (circuitId.startsWith('circuit_')) {
        // Buscar en la lista de circuitos
        if (matchesData.circuits && Array.isArray(matchesData.circuits)) {
            const circuit = matchesData.circuits.find(c => c.id === circuitId);
            if (circuit && circuit.name) {
                return circuit.name;
            }
        }
        
        // Si no se encuentra, intentar obtener de los torneos
        const tournament = matchesData.tournaments.find(t => t.circuit === circuitId);
        if (tournament && tournament.circuitName) {
            return tournament.circuitName;
        }
        
        // Si a√∫n no se encuentra, retornar un nombre m√°s legible
        return circuitId.replace('circuit_', 'Circuito #').substring(0, 20);
    }
    
    // Si no es un ID, retornar tal cual (es el nombre)
    return circuitId;
}

// ============================================
// FUNCI√ìN PARA DETECTAR SI ES VICTORIA
// ============================================

function isVictory(result) {
    if (!result) return false;
    
    // Normalizar el resultado
    const normalized = String(result).trim().toLowerCase();
    
    // Casos de victoria
    const victoryPatterns = [
        '1¬∫',
        '1¬∞',
        '1',
        'primero',
        'ganador',
        'campe√≥n',
        'campeon',
        'victoria',
        'winner',
        'first'
    ];
    
    // Verificar si coincide con alg√∫n patr√≥n
    for (const pattern of victoryPatterns) {
        if (normalized === pattern || normalized === pattern.toLowerCase()) {
            return true;
        }
    }
    
    // Verificar si empieza con "1" seguido de caracteres no num√©ricos
    if (/^1[^\d]/.test(normalized)) {
        return true;
    }
    
    return false;
}

// ============================================
// FUNCI√ìN PARA EXTRAER POSICI√ìN NUM√âRICA
// ============================================

function extractPosition(result) {
    if (!result) return null;
    
    const str = String(result).trim();
    
    // Intentar extraer n√∫mero al inicio
    const match = str.match(/^(\d+)/);
    if (match) {
        return parseInt(match[1]);
    }
    
    // Casos especiales
    const specialCases = {
        'primero': 1,
        'segundo': 2,
        'tercero': 3,
        'cuarto': 4,
        'quinto': 5,
        'first': 1,
        'second': 2,
        'third': 3
    };
    
    const normalized = str.toLowerCase();
    if (specialCases[normalized]) {
        return specialCases[normalized];
    }
    
    return null;
}

// ============================================
// INICIALIZAR COMPARATIVA DE CIRCUITOS
// ============================================

function initCircuitComparison() {
    console.log('üîÑ Inicializando comparativa de circuitos...');
    
    // Obtener circuitos √∫nicos de los torneos
    const circuits = getCircuitsFromTournaments();
    
    console.log('üìä Circuitos encontrados:', circuits.length);
    
    if (circuits.length === 0) {
        document.getElementById('circuitCheckboxes').style.display = 'none';
        document.getElementById('noCircuitsMessage').style.display = 'block';
        return;
    }
    
    document.getElementById('circuitCheckboxes').style.display = 'grid';
    document.getElementById('noCircuitsMessage').style.display = 'none';
    
    // Crear checkboxes
    renderCircuitCheckboxes(circuits);
    
    // Seleccionar todos por defecto (m√°ximo 5)
    const circuitsToSelect = circuits.slice(0, 5);
    circuitsToSelect.forEach(circuit => selectedCircuits.add(circuit.id));
    
    // Actualizar UI
    updateCheckboxStates();
    
    // Renderizar gr√°fica
    updateCircuitComparison();
}

// ============================================
// OBTENER CIRCUITOS DE TORNEOS
// ============================================

function getCircuitsFromTournaments() {
    const circuitMap = new Map();
    
    matchesData.tournaments.forEach(tournament => {
        if (tournament.circuit && tournament.circuit.trim() !== '') {
            const circuitId = tournament.circuit.trim();
            const circuitName = getCircuitName(circuitId);
            
            if (!circuitMap.has(circuitId)) {
                circuitMap.set(circuitId, {
                    id: circuitId,
                    name: circuitName,
                    count: 0,
                    tournaments: []
                });
            }
            
            const circuit = circuitMap.get(circuitId);
            circuit.count++;
            circuit.tournaments.push(tournament);
        }
    });
    
    // Convertir a array y ordenar por cantidad de torneos
    return Array.from(circuitMap.values())
        .sort((a, b) => b.count - a.count);
}

// ============================================
// RENDERIZAR CHECKBOXES
// ============================================

function renderCircuitCheckboxes(circuits) {
    const container = document.getElementById('circuitCheckboxes');
    
    container.innerHTML = circuits.map((circuit, index) => `
        <div class="circuit-checkbox ${selectedCircuits.has(circuit.id) ? 'selected' : ''}" 
             onclick="toggleCircuitSelection('${escapeHtml(circuit.id)}')">
            <input 
                type="checkbox" 
                id="circuit_${index}"
                ${selectedCircuits.has(circuit.id) ? 'checked' : ''}
                onchange="toggleCircuitSelection('${escapeHtml(circuit.id)}')"
                onclick="event.stopPropagation()">
            <label for="circuit_${index}">${escapeHtml(circuit.name)}</label>
            <span class="circuit-count">${circuit.count}</span>
        </div>
    `).join('');
}

// ============================================
// TOGGLE SELECCI√ìN DE CIRCUITO
// ============================================

function toggleCircuitSelection(circuitId) {
    if (selectedCircuits.has(circuitId)) {
        selectedCircuits.delete(circuitId);
    } else {
        selectedCircuits.add(circuitId);
    }
    
    updateCheckboxStates();
    updateCircuitComparison();
}

// ============================================
// ACTUALIZAR ESTADOS DE CHECKBOXES
// ============================================

function updateCheckboxStates() {
    const circuits = getCircuitsFromTournaments();
    const checkboxes = document.querySelectorAll('.circuit-checkbox');
    
    checkboxes.forEach((checkbox, index) => {
        const circuit = circuits[index];
        if (!circuit) return;
        
        const input = checkbox.querySelector('input[type="checkbox"]');
        
        if (selectedCircuits.has(circuit.id)) {
            checkbox.classList.add('selected');
            input.checked = true;
        } else {
            checkbox.classList.remove('selected');
            input.checked = false;
        }
    });
}

// ============================================
// SELECCIONAR TODOS LOS CIRCUITOS
// ============================================

function selectAllCircuits() {
    const circuits = getCircuitsFromTournaments();
    selectedCircuits.clear();
    circuits.forEach(circuit => selectedCircuits.add(circuit.id));
    updateCheckboxStates();
    updateCircuitComparison();
}

// ============================================
// LIMPIAR SELECCI√ìN
// ============================================

function clearCircuitSelection() {
    selectedCircuits.clear();
    updateCheckboxStates();
    updateCircuitComparison();
}

// ============================================
// ACTUALIZAR COMPARATIVA
// ============================================

function updateCircuitComparison() {
    if (selectedCircuits.size === 0) {
        destroyCircuitChart();
        document.getElementById('circuitComparisonTableBody').innerHTML = `
            <tr>
                <td colspan="7" style="text-align: center; color: #86868b; padding: 40px;">
                    Selecciona al menos un circuito para ver la comparativa
                </td>
            </tr>
        `;
        return;
    }
    
    const metric = document.getElementById('comparisonMetric').value;
    const circuitsData = calculateCircuitStats();
    
    console.log('üìä Datos de circuitos calculados:', circuitsData);
    
    renderCircuitChart(circuitsData, metric);
    renderCircuitTable(circuitsData);
}

// ============================================
// CALCULAR ESTAD√çSTICAS DE CIRCUITOS
// ============================================

function calculateCircuitStats() {
    const stats = [];
    const circuits = getCircuitsFromTournaments();
    
    selectedCircuits.forEach(circuitId => {
        const circuit = circuits.find(c => c.id === circuitId);
        if (!circuit) return;
        
        const tournaments = matchesData.tournaments.filter(t => t.circuit === circuitId);
        
        if (tournaments.length === 0) return;
        
        // Calcular estad√≠sticas
        const totalTournaments = tournaments.length;
        
        // Contar victorias con la nueva funci√≥n mejorada
        const totalWins = tournaments.filter(t => isVictory(t.result)).length;
        
        console.log(`üèÜ ${circuit.name}: ${totalWins} victorias de ${totalTournaments} torneos`);
        
        const winRate = totalTournaments > 0 ? (totalWins / totalTournaments * 100) : 0;
        
        // Calcular total de partidas
        let totalMatches = 0;
        let totalMatchWins = 0;
        
        tournaments.forEach(t => {
            if (t.stats) {
                // Intentar diferentes nombres de campos
                const wins = t.stats.victorias || t.stats.wins || t.stats.gamesWon || 0;
                const losses = t.stats.derrotas || t.stats.losses || t.stats.gamesLost || 0;
                
                totalMatches += wins + losses;
                totalMatchWins += wins;
            }
        });
        
        // Calcular posici√≥n promedio
        const positions = tournaments
            .map(t => extractPosition(t.result))
            .filter(p => p !== null && p > 0);
        
        const avgPosition = positions.length > 0 
            ? positions.reduce((a, b) => a + b, 0) / positions.length 
            : 0;
        
        const bestPosition = positions.length > 0 ? Math.min(...positions) : 0;
        
        // √öltima participaci√≥n
        const sortedTournaments = tournaments.sort((a, b) => new Date(b.date) - new Date(a.date));
        const lastDate = sortedTournaments[0]?.date || '';
        
        const circuitStats = {
            id: circuitId,
            name: circuit.name,
            tournaments: totalTournaments,
            wins: totalWins,
            winRate: winRate,
            avgPosition: avgPosition,
            bestPosition: bestPosition,
            totalMatches: totalMatches,
            totalMatchWins: totalMatchWins,
            lastDate: lastDate
        };
        
        console.log('üìä Estad√≠sticas calculadas:', circuitStats);
        
        stats.push(circuitStats);
    });
    
    return stats;
}

// ============================================
// RENDERIZAR GR√ÅFICA DE CIRCUITOS (L√çNEAS)
// ============================================

function renderCircuitChart(circuitsData, metric) {
    const ctx = document.getElementById('circuitComparisonChart');
    
    if (!ctx) {
        console.error('Canvas no encontrado');
        return;
    }
    
    // Destruir gr√°fica anterior
    destroyCircuitChart();
    
    // Preparar datos seg√∫n la m√©trica
    let labels = circuitsData.map(c => c.name);
    let data, label, yAxisLabel;
    
    switch(metric) {
        case 'tournaments':
            data = circuitsData.map(c => c.tournaments);
            label = 'N√∫mero de Torneos';
            yAxisLabel = 'Torneos';
            break;
        case 'winRate':
            data = circuitsData.map(c => parseFloat(c.winRate.toFixed(1)));
            label = 'Tasa de Victoria (%)';
            yAxisLabel = 'Porcentaje (%)';
            break;
        case 'avgPosition':
            data = circuitsData.map(c => c.avgPosition > 0 ? parseFloat(c.avgPosition.toFixed(1)) : 0);
            label = 'Posici√≥n Promedio';
            yAxisLabel = 'Posici√≥n';
            break;
        case 'totalMatches':
            data = circuitsData.map(c => c.totalMatches);
            label = 'Total de Partidas';
            yAxisLabel = 'Partidas';
            break;
        case 'totalWins':
            data = circuitsData.map(c => c.wins);
            label = 'Total de Victorias';
            yAxisLabel = 'Victorias en Torneos';
            break;
        default:
            data = circuitsData.map(c => c.tournaments);
            label = 'N√∫mero de Torneos';
            yAxisLabel = 'Torneos';
    }
    
    console.log('üìä Renderizando gr√°fica:', { metric, label, data });
    
    // Si hay m√∫ltiples circuitos, crear l√≠nea conectada
    if (circuitsData.length > 1) {
        // Crear una sola l√≠nea que conecta todos los puntos
        const mainDataset = {
            label: label,
            data: data,
            borderColor: '#94a3b8',
            backgroundColor: 'transparent',
            borderWidth: 2,
            borderDash: [5, 5],
            pointRadius: 0,
            tension: 0.4,
            fill: false
        };
        
        // Crear puntos individuales de colores
        const pointDatasets = circuitsData.map((circuit, index) => {
            const color = circuitColors[index % circuitColors.length];
            
            return {
                label: circuit.name,
                data: data.map((_, i) => i === index ? data[i] : null),
                borderColor: color,
                backgroundColor: color,
                borderWidth: 3,
                pointRadius: 8,
                pointHoverRadius: 10,
                pointBackgroundColor: color,
                pointBorderColor: '#fff',
                pointBorderWidth: 3,
                tension: 0.4,
                fill: false,
                showLine: false
            };
        });
        
        // Crear gr√°fica con l√≠nea base y puntos de colores
        circuitComparisonChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: labels,
                datasets: [mainDataset, ...pointDatasets]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: {
                    mode: 'point',
                    intersect: true
                },
                plugins: {
                    legend: {
                        display: true,
                        position: 'top',
                        labels: {
                            font: {
                                family: '-apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif',
                                size: 12,
                                weight: '500'
                            },
                            padding: 16,
                            usePointStyle: true,
                            pointStyle: 'circle',
                            filter: function(item, chart) {
                                return item.text !== label;
                            }
                        }
                    },
                    tooltip: {
                        backgroundColor: 'rgba(0, 0, 0, 0.8)',
                        padding: 12,
                        titleFont: {
                            size: 14,
                            weight: '600'
                        },
                        bodyFont: {
                            size: 13
                        },
                        borderColor: 'rgba(255, 255, 255, 0.2)',
                        borderWidth: 1,
                        displayColors: true,
                        callbacks: {
                            label: function(context) {
                                if (context.dataset.label === label) return null;
                                
                                let labelText = context.dataset.label || '';
                                if (labelText) {
                                    labelText += ': ';
                                }
                                labelText += context.parsed.y;
                                if (metric === 'winRate') {
                                    labelText += '%';
                                } else if (metric === 'avgPosition') {
                                    labelText += '¬∫';
                                }
                                return labelText;
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        grid: {
                            color: 'rgba(0, 0, 0, 0.05)',
                            drawBorder: false
                        },
                        title: {
                            display: true,
                            text: yAxisLabel,
                            font: {
                                size: 13,
                                weight: '600'
                            }
                        },
                        ticks: {
                            font: {
                                size: 12
                            },
                            padding: 8,
                            callback: function(value) {
                                if (metric === 'winRate') {
                                    return value + '%';
                                } else if (metric === 'avgPosition') {
                                    return value + '¬∫';
                                }
                                return value;
                            }
                        }
                    },
                    x: {
                        grid: {
                            display: false
                        },
                        ticks: {
                            font: {
                                size: 12,
                                weight: '500'
                            },
                            padding: 8
                        }
                    }
                }
            }
        });
    } else {
        // Para un solo circuito, usar gr√°fica de barras simple
        circuitComparisonChart = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: labels,
                datasets: [{
                    label: label,
                    data: data,
                    backgroundColor: circuitColors[0] + '40',
                    borderColor: circuitColors[0],
                    borderWidth: 2,
                    borderRadius: 8
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        backgroundColor: 'rgba(0, 0, 0, 0.8)',
                        padding: 12,
                        callbacks: {
                            label: function(context) {
                                let labelText = label + ': ' + context.parsed.y;
                                if (metric === 'winRate') {
                                    labelText += '%';
                                } else if (metric === 'avgPosition') {
                                    labelText += '¬∫';
                                }
                                return labelText;
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        grid: {
                            color: 'rgba(0, 0, 0, 0.05)'
                        },
                        title: {
                            display: true,
                            text: yAxisLabel
                        },
                        ticks: {
                            callback: function(value) {
                                if (metric === 'winRate') {
                                    return value + '%';
                                } else if (metric === 'avgPosition') {
                                    return value + '¬∫';
                                }
                                return value;
                            }
                        }
                    }
                }
            }
        });
    }
}

// ============================================
// DESTRUIR GR√ÅFICA
// ============================================

function destroyCircuitChart() {
    if (circuitComparisonChart) {
        circuitComparisonChart.destroy();
        circuitComparisonChart = null;
    }
}

// ============================================
// RENDERIZAR TABLA COMPARATIVA
// ============================================

function renderCircuitTable(circuitsData) {
    const tbody = document.getElementById('circuitComparisonTableBody');
    
    if (circuitsData.length === 0) {
        tbody.innerHTML = `
            <tr>
                <td colspan="7" style="text-align: center; color: #86868b; padding: 40px;">
                    No hay datos para mostrar
                </td>
            </tr>
        `;
        return;
    }
    
    tbody.innerHTML = circuitsData.map((circuit, index) => {
        const color = circuitColors[index % circuitColors.length];
        const winRateClass = circuit.winRate >= 50 ? 'positive' : circuit.winRate >= 30 ? 'neutral' : 'negative';
        const positionClass = circuit.avgPosition <= 3 ? 'positive' : circuit.avgPosition <= 8 ? 'neutral' : 'negative';
        
        return `
            <tr>
                <td>
                    <div class="circuit-name">
                        <div class="circuit-color" style="background-color: ${color};"></div>
                        ${escapeHtml(circuit.name)}
                    </div>
                </td>
                <td class="metric-value">${circuit.tournaments}</td>
                <td class="metric-value">${circuit.wins}</td>
                <td class="metric-value ${winRateClass}">${circuit.winRate.toFixed(1)}%</td>
                <td class="metric-value ${positionClass}">
                    ${circuit.avgPosition > 0 ? circuit.avgPosition.toFixed(1) + '¬∫' : '-'}
                </td>
                <td class="metric-value positive">
                    ${circuit.bestPosition > 0 ? circuit.bestPosition + '¬∫' : '-'}
                </td>
                <td>${circuit.lastDate ? new Date(circuit.lastDate).toLocaleDateString('es-ES') : '-'}</td>
            </tr>
        `;
    }).join('');
}

// ============================================
// FUNCI√ìN AUXILIAR: ESCAPE HTML
// ============================================

function escapeHtml(text) {
    if (!text) return '';
    const map = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#039;'
    };
    return String(text).replace(/[&<>"']/g, m => map[m]);
}

// ============================================
// INICIALIZAR AL CARGAR LA P√ÅGINA
// ============================================

document.addEventListener('DOMContentLoaded', () => {
    setTimeout(() => {
        if (typeof initCircuitComparison === 'function') {
            initCircuitComparison();
        }
    }, 500);
});

// Tambi√©n actualizar cuando cambien los datos
function updateCircuitComparisonIfVisible() {
    const comparisonChart = document.getElementById('circuitComparisonChart');
    if (comparisonChart && comparisonChart.offsetParent !== null) {
        initCircuitComparison();
    }
}

console.log('‚úÖ Comparativa de circuitos v2 cargada (victorias mejoradas + todas las m√©tricas)');
</script>


<!-- Comparativa de Torneos -->
<section class="analysis-section tournament-comparison-wrapper">
    <div class="section-header-analysis">
        <div class="section-title-group">
            <h2 class="section-main-title">Comparativa Hist√≥rica de Torneos</h2>
            <p class="section-subtitle-text">Analiza tu evoluci√≥n en el mismo torneo a trav√©s de los a√±os</p>
        </div>
    </div>

    <div class="tournament-comparison-container">
        <!-- Selector Card -->
        <div class="tournament-selector-wrapper">
            <div class="selector-card-inner">
                <div class="selector-label-wrapper">
                    <label for="tournamentSelectorAnalysis" class="tournament-selector-label">
                        <span class="label-icon">üèÜ</span>
                        <span class="label-text">Selecciona un Torneo</span>
                    </label>
                </div>
                <select id="tournamentSelectorAnalysis" class="tournament-selector-input">
                    <option value="">-- Elige un torneo para comparar --</option>
                </select>
            </div>
        </div>

        <!-- Estados -->
        <div id="comparisonLoadingAnalysis" class="comparison-state-box" style="display: none;">
            <div class="state-spinner"></div>
            <p class="state-text">Analizando datos hist√≥ricos...</p>
        </div>

        <div id="comparisonEmptyAnalysis" class="comparison-state-box">
            <div class="state-icon">üèÜ</div>
            <h3 class="state-title">Elige un torneo</h3>
            <p class="state-text">Selecciona un torneo del men√∫ para ver su an√°lisis hist√≥rico</p>
        </div>

        <div id="comparisonNoDataAnalysis" class="comparison-state-box" style="display: none;">
            <div class="state-icon">üìÖ</div>
            <h3 class="state-title">Datos insuficientes</h3>
            <p class="state-text">Este torneo solo tiene una edici√≥n. Se necesitan al menos 2 a√±os para comparar.</p>
        </div>

        <!-- Contenido Principal -->
        <div id="comparisonContentAnalysis" class="comparison-main-content" style="display: none;">
            <!-- Chart Full Width -->
            <div class="tournament-chart-full">
                <div class="tournament-chart-box">
                    <div class="chart-box-header">
                        <h3 class="chart-box-title">üìà Evoluci√≥n de tu Posici√≥n</h3>
                        <p class="chart-box-subtitle">Tendencia a√±o tras a√±o</p>
                    </div>
                    <div class="chart-box-canvas">
                        <canvas id="positionEvolutionChartAnalysis"></canvas>
                    </div>
                </div>
            </div>

            <!-- Detailed Table -->
            <div class="tournament-table-box">
                <div class="table-box-header">
                    <h3 class="table-box-title">üìã Historial Detallado por A√±o</h3>
                </div>
                <div class="table-box-content">
                    <div class="table-scroll-wrapper">
                        <table class="tournament-detail-table">
                            <thead>
                                <tr>
                                    <th class="col-year">A√±o</th>
                                    <th class="col-position">Posici√≥n</th>
                                    <th class="col-players">Jugadores</th>
                                    <th class="col-modality">Modalidad</th>
                                    <th class="col-prize">Premio</th>
                                    <th class="col-notes">Notas</th>
                                </tr>
                            </thead>
                            <tbody id="comparisonTableBodyAnalysis">
                                <!-- Filled by JS -->
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
    </div>
</section>



	 
		
<!-- Indicador de sincronizaci√≥n -->
    <div id="syncIndicator" style="position: fixed; bottom: 20px; right: 20px; padding: 12px 20px; background: #34c759; color: white; border-radius: 12px; font-weight: 600; opacity: 0; transition: opacity 0.3s; pointer-events: none; z-index: 1000;">
        ‚òÅÔ∏è Sincronizado
    </div>

    <!-- JavaScript -->
	 <script src="js/cloud-sync.js"></script>
    <script src="js/common.js"></script>
    <script src="js/tournaments.js"></script>
	 <script src="js/bottom-nav.js"></script>
	 <script src="js/top-nav.js"></script>
	 <script src="js/tournament-comparison-analisis.js"></script>
<script>
    document.addEventListener('DOMContentLoaded', () => {
        // Tu c√≥digo actual...
        
        initTournamentComparisonAnalysis(); // ‚Üê A√ëADE ESTO
    });
</script>
</body>
</html>








