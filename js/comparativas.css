

	<!-- ============================================ -->
<!-- COMPARATIVA DE CIRCUITOS - VERSI√ìN CORREGIDA V3 -->
<!-- Con detecci√≥n mejorada de victorias, m√©tricas Y POSICIONES -->
<!-- ============================================ -->

<script>
// ============================================
// VARIABLES GLOBALES PARA COMPARATIVA
// ============================================

let circuitComparisonChart = null;
let selectedCircuits = new Set();
const circuitColors = [
    '#3b82f6', // Azul
    '#ef4444', // Rojo
    '#10b981', // Verde
    '#f59e0b', // Amarillo
    '#8b5cf6', // P√∫rpura
    '#ec4899', // Rosa
    '#14b8a6', // Turquesa
    '#f97316', // Naranja
    '#6366f1', // √çndigo
    '#84cc16', // Lima
];

// ============================================
// FUNCI√ìN PARA OBTENER NOMBRE REAL DEL CIRCUITO
// ============================================

function getCircuitName(circuitId) {
    if (!circuitId) return 'Sin circuito';
    
    // Si es un ID (empieza con "circuit_"), buscar el nombre real
    if (circuitId.startsWith('circuit_')) {
        // Buscar en la lista de circuitos
        if (matchesData.circuits && Array.isArray(matchesData.circuits)) {
            const circuit = matchesData.circuits.find(c => c.id === circuitId);
            if (circuit && circuit.name) {
                return circuit.name;
            }
        }
        
        // Si no se encuentra, intentar obtener de los torneos
        const tournament = matchesData.tournaments.find(t => t.circuit === circuitId);
        if (tournament && tournament.circuitName) {
            return tournament.circuitName;
        }
        
        // Si a√∫n no se encuentra, retornar un nombre m√°s legible
        return circuitId.replace('circuit_', 'Circuito #').substring(0, 20);
    }
    
    // Si no es un ID, retornar tal cual (es el nombre)
    return circuitId;
}

// ============================================
// FUNCI√ìN PARA DETECTAR SI ES VICTORIA
// ============================================

function isVictory(result) {
    if (!result) return false;
    
    // Normalizar el resultado
    const normalized = String(result).trim().toLowerCase();
    
    // Casos de victoria
    const victoryPatterns = [
        '1¬∫',
        '1¬∞',
        '1',
        'primero',
        'ganador',
        'campe√≥n',
        'campeon',
        'victoria',
        'winner',
        'first'
    ];
    
    // Verificar si coincide con alg√∫n patr√≥n
    for (const pattern of victoryPatterns) {
        if (normalized === pattern || normalized === pattern.toLowerCase()) {
            return true;
        }
    }
    
    // Verificar si empieza con "1" seguido de caracteres no num√©ricos
    if (/^1[^\d]/.test(normalized)) {
        return true;
    }
    
    return false;
}

// ============================================
// FUNCI√ìN PARA EXTRAER POSICI√ìN NUM√âRICA
// ============================================

function extractPosition(result) {
    if (!result) return null;
    
    const str = String(result).trim();
    
    // Intentar extraer n√∫mero al inicio
    const match = str.match(/^(\d+)/);
    if (match) {
        return parseInt(match[1]);
    }
    
    // Casos especiales
    const specialCases = {
        'primero': 1,
        'segundo': 2,
        'tercero': 3,
        'cuarto': 4,
        'quinto': 5,
        'first': 1,
        'second': 2,
        'third': 3
    };
    
    const normalized = str.toLowerCase();
    if (specialCases[normalized]) {
        return specialCases[normalized];
    }
    
    return null;
}

// ============================================
// ‚úÖ NUEVA FUNCI√ìN: DETECTAR POSICI√ìN (MEJORADA)
// Prioriza Campe√≥n > Subcampe√≥n > Semifinales > N√∫meros
// ============================================

function detectTournamentPosition(result, position) {
    let detectedPosition = '-';
    let positionNumber = null;
    
    // Si tiene position directamente, tiene prioridad
    if (position) {
        positionNumber = parseInt(position);
        detectedPosition = `${positionNumber}¬∫`;
        return { position: detectedPosition, positionNumber };
    }
    
    if (!result) {
        return { position: '-', positionNumber: null };
    }
    
    const resultLower = result.toLowerCase().trim();
    
    // ORDEN IMPORTA - De m√°s espec√≠fico a menos
    
    // 1. Subcampe√≥n / Finalista / 2¬∫
    if (resultLower.includes('subcampe√≥n') || resultLower.includes('subcampeon') || 
        resultLower === 'subcampeon' || resultLower === 'subcampe√≥n' ||
        resultLower.includes('finalista') || resultLower === '2¬∫' || 
        resultLower === '2' || resultLower === '2¬∫ puesto' || resultLower === 'segundo') {
        detectedPosition = '2¬∫';
        positionNumber = 2;
    }
    // 2. Semifinales (puede ser 3¬∫ o 4¬∫)
    else if (resultLower.includes('semifinal') || resultLower.includes('semi-final') ||
             resultLower === 'semifinalista' || resultLower === 'semifinales') {
        const match = result.match(/(\d+)/);
        if (match) {
            positionNumber = parseInt(match[1]);
            detectedPosition = `${positionNumber}¬∫`;
        } else {
            detectedPosition = '3¬∫-4¬∫';
            positionNumber = 3;
        }
    }
    // 3. Tercero
    else if (resultLower === '3' || resultLower === '3¬∫' || resultLower === '3¬∫ puesto' || 
             resultLower === 'tercero' || resultLower === 'tercer puesto') {
        detectedPosition = '3¬∫';
        positionNumber = 3;
    }
    // 4. Cuarto
    else if (resultLower === '4' || resultLower === '4¬∫' || resultLower === '4¬∫ puesto' || 
             resultLower === 'cuarto' || resultLower === 'cuarto puesto') {
        detectedPosition = '4¬∫';
        positionNumber = 4;
    }
    // 5. Campe√≥n / Ganador / 1¬∫
    else if (resultLower.includes('campe√≥n') || resultLower.includes('campeon') || 
             resultLower === 'campeon' || resultLower === 'campe√≥n' ||
             resultLower === '1' || resultLower === '1¬∫' || resultLower === 'primero' ||
             resultLower === 'ganador' || resultLower === 'winner') {
        detectedPosition = '1¬∫';
        positionNumber = 1;
    }
    // 6. Intentar extraer cualquier n√∫mero
    else {
        const match = result.match(/(\d+)/);
        if (match) {
            positionNumber = parseInt(match[1]);
            detectedPosition = `${positionNumber}¬∫`;
        } else {
            detectedPosition = result;
        }
    }
    
    return { position: detectedPosition, positionNumber };
}

// ============================================
// INICIALIZAR COMPARATIVA DE CIRCUITOS
// ============================================

function initCircuitComparison() {
    console.log('üîÑ Inicializando comparativa de circuitos...');
    
    // Obtener circuitos √∫nicos de los torneos
    const circuits = getCircuitsFromTournaments();
    
    console.log('üìä Circuitos encontrados:', circuits.length);
    
    if (circuits.length === 0) {
        document.getElementById('circuitCheckboxes').style.display = 'none';
        document.getElementById('noCircuitsMessage').style.display = 'block';
        return;
    }
    
    document.getElementById('circuitCheckboxes').style.display = 'grid';
    document.getElementById('noCircuitsMessage').style.display = 'none';
    
    // Crear checkboxes
    renderCircuitCheckboxes(circuits);
    
    // Seleccionar todos por defecto (m√°ximo 5)
    const circuitsToSelect = circuits.slice(0, 5);
    circuitsToSelect.forEach(circuit => selectedCircuits.add(circuit.id));
    
    // Actualizar UI
    updateCheckboxStates();
    
    // Renderizar gr√°fica
    updateCircuitComparison();
}

// ============================================
// OBTENER CIRCUITOS DE TORNEOS
// ============================================

function getCircuitsFromTournaments() {
    const circuitMap = new Map();
    
    matchesData.tournaments.forEach(tournament => {
        if (tournament.circuit && tournament.circuit.trim() !== '') {
            const circuitId = tournament.circuit.trim();
            const circuitName = getCircuitName(circuitId);
            
            if (!circuitMap.has(circuitId)) {
                circuitMap.set(circuitId, {
                    id: circuitId,
                    name: circuitName,
                    count: 0,
                    tournaments: []
                });
            }
            
            const circuit = circuitMap.get(circuitId);
            circuit.count++;
            circuit.tournaments.push(tournament);
        }
    });
    
    // Convertir a array y ordenar por cantidad de torneos
    return Array.from(circuitMap.values())
        .sort((a, b) => b.count - a.count);
}

// ============================================
// RENDERIZAR CHECKBOXES
// ============================================

function renderCircuitCheckboxes(circuits) {
    const container = document.getElementById('circuitCheckboxes');
    
    container.innerHTML = circuits.map((circuit, index) => `
        <div class="circuit-checkbox ${selectedCircuits.has(circuit.id) ? 'selected' : ''}" 
             onclick="toggleCircuitSelection('${escapeHtml(circuit.id)}')">
            <input 
                type="checkbox" 
                id="circuit_${index}"
                ${selectedCircuits.has(circuit.id) ? 'checked' : ''}
                onchange="toggleCircuitSelection('${escapeHtml(circuit.id)}')"
                onclick="event.stopPropagation()">
            <label for="circuit_${index}">${escapeHtml(circuit.name)}</label>
            <span class="circuit-count">${circuit.count}</span>
        </div>
    `).join('');
}

// ============================================
// TOGGLE SELECCI√ìN DE CIRCUITO
// ============================================

function toggleCircuitSelection(circuitId) {
    if (selectedCircuits.has(circuitId)) {
        selectedCircuits.delete(circuitId);
    } else {
        selectedCircuits.add(circuitId);
    }
    
    updateCheckboxStates();
    updateCircuitComparison();
}

// ============================================
// ACTUALIZAR ESTADOS DE CHECKBOXES
// ============================================

function updateCheckboxStates() {
    const circuits = getCircuitsFromTournaments();
    const checkboxes = document.querySelectorAll('.circuit-checkbox');
    
    checkboxes.forEach((checkbox, index) => {
        const circuit = circuits[index];
        if (!circuit) return;
        
        const input = checkbox.querySelector('input[type="checkbox"]');
        
        if (selectedCircuits.has(circuit.id)) {
            checkbox.classList.add('selected');
            input.checked = true;
        } else {
            checkbox.classList.remove('selected');
            input.checked = false;
        }
    });
}

// ============================================
// SELECCIONAR TODOS LOS CIRCUITOS
// ============================================

function selectAllCircuits() {
    const circuits = getCircuitsFromTournaments();
    selectedCircuits.clear();
    circuits.forEach(circuit => selectedCircuits.add(circuit.id));
    updateCheckboxStates();
    updateCircuitComparison();
}

// ============================================
// LIMPIAR SELECCI√ìN
// ============================================

function clearCircuitSelection() {
    selectedCircuits.clear();
    updateCheckboxStates();
    updateCircuitComparison();
}

// ============================================
// ACTUALIZAR COMPARATIVA
// ============================================

function updateCircuitComparison() {
    if (selectedCircuits.size === 0) {
        destroyCircuitChart();
        document.getElementById('circuitComparisonTableBody').innerHTML = `
            <tr>
                <td colspan="7" style="text-align: center; color: #86868b; padding: 40px;">
                    Selecciona al menos un circuito para ver la comparativa
                </td>
            </tr>
        `;
        return;
    }
    
    const metric = document.getElementById('comparisonMetric').value;
    const circuitsData = calculateCircuitStats();
    
    console.log('üìä Datos de circuitos calculados:', circuitsData);
    
    renderCircuitChart(circuitsData, metric);
    renderCircuitTable(circuitsData);
}

// ============================================
// ‚úÖ CALCULAR ESTAD√çSTICAS DE CIRCUITOS (FIXED)
// Ahora usa detectTournamentPosition para mejor detecci√≥n
// ============================================

function calculateCircuitStats() {
    const stats = [];
    const circuits = getCircuitsFromTournaments();
    
    selectedCircuits.forEach(circuitId => {
        const circuit = circuits.find(c => c.id === circuitId);
        if (!circuit) return;
        
        const tournaments = matchesData.tournaments.filter(t => t.circuit === circuitId);
        
        if (tournaments.length === 0) return;
        
        // Calcular estad√≠sticas
        const totalTournaments = tournaments.length;
        
        // Contar victorias con la nueva funci√≥n mejorada
        const totalWins = tournaments.filter(t => isVictory(t.result)).length;
        
        console.log(`üèÜ ${circuit.name}: ${totalWins} victorias de ${totalTournaments} torneos`);
        
        const winRate = totalTournaments > 0 ? (totalWins / totalTournaments * 100) : 0;
        
        // Calcular total de partidas
        let totalMatches = 0;
        let totalMatchWins = 0;
        
        tournaments.forEach(t => {
            if (t.stats) {
                // Intentar diferentes nombres de campos
                const wins = t.stats.victorias || t.stats.wins || t.stats.gamesWon || 0;
                const losses = t.stats.derrotas || t.stats.losses || t.stats.gamesLost || 0;
                
                totalMatches += wins + losses;
                totalMatchWins += wins;
            }
        });
        
        // ‚úÖ FIXED: Calcular posici√≥n promedio y mejor posici√≥n con detecci√≥n mejorada
        let bestPositionNumber = Infinity;
        let bestPositionText = '-';
        const validPositions = [];
        
        tournaments.forEach(tournament => {
            const { position, positionNumber } = detectTournamentPosition(
                tournament.result, 
                tournament.position
            );
            
            if (positionNumber !== null && positionNumber > 0) {
                validPositions.push(positionNumber);
                
                if (positionNumber < bestPositionNumber) {
                    bestPositionNumber = positionNumber;
                    bestPositionText = position;
                }
            }
        });
        
        const avgPosition = validPositions.length > 0 
            ? validPositions.reduce((a, b) => a + b, 0) / validPositions.length 
            : 0;
        
        const bestPosition = bestPositionNumber !== Infinity ? bestPositionNumber : 0;
        
        // √öltima participaci√≥n
        const sortedTournaments = tournaments.sort((a, b) => new Date(b.date) - new Date(a.date));
        const lastDate = sortedTournaments[0]?.date || '';
        
        const circuitStats = {
            id: circuitId,
            name: circuit.name,
            tournaments: totalTournaments,
            wins: totalWins,
            winRate: winRate,
            avgPosition: avgPosition,
            bestPosition: bestPosition,
            totalMatches: totalMatches,
            totalMatchWins: totalMatchWins,
            lastDate: lastDate
        };
        
        console.log('üìä Estad√≠sticas calculadas:', circuitStats);
        
        stats.push(circuitStats);
    });
    
    return stats;
}

// ============================================
// RENDERIZAR GR√ÅFICA DE CIRCUITOS (L√çNEAS)
// ============================================

function renderCircuitChart(circuitsData, metric) {
    const ctx = document.getElementById('circuitComparisonChart');
    
    if (!ctx) {
        console.error('Canvas no encontrado');
        return;
    }
    
    // Destruir gr√°fica anterior
    destroyCircuitChart();
    
    // Preparar datos seg√∫n la m√©trica
    let labels = circuitsData.map(c => c.name);
    let data, label, yAxisLabel;
    
    switch(metric) {
        case 'tournaments':
            data = circuitsData.map(c => c.tournaments);
            label = 'N√∫mero de Torneos';
            yAxisLabel = 'Torneos';
            break;
        case 'winRate':
            data = circuitsData.map(c => parseFloat(c.winRate.toFixed(1)));
            label = 'Tasa de Victoria (%)';
            yAxisLabel = 'Porcentaje (%)';
            break;
        case 'avgPosition':
            data = circuitsData.map(c => c.avgPosition > 0 ? parseFloat(c.avgPosition.toFixed(1)) : 0);
            label = 'Posici√≥n Promedio';
            yAxisLabel = 'Posici√≥n';
            break;
        case 'totalMatches':
            data = circuitsData.map(c => c.totalMatches);
            label = 'Total de Partidas';
            yAxisLabel = 'Partidas';
            break;
        case 'totalWins':
            data = circuitsData.map(c => c.wins);
            label = 'Total de Victorias';
            yAxisLabel = 'Victorias en Torneos';
            break;
        default:
            data = circuitsData.map(c => c.tournaments);
            label = 'N√∫mero de Torneos';
            yAxisLabel = 'Torneos';
    }
    
    console.log('üìä Renderizando gr√°fica:', { metric, label, data });
    
    // Si hay m√∫ltiples circuitos, crear l√≠nea conectada
    if (circuitsData.length > 1) {
        // Crear una sola l√≠nea que conecta todos los puntos
        const mainDataset = {
            label: label,
            data: data,
            borderColor: '#94a3b8',
            backgroundColor: 'transparent',
            borderWidth: 2,
            borderDash: [5, 5],
            pointRadius: 0,
            tension: 0.4,
            fill: false
        };
        
        // Crear puntos individuales de colores
        const pointDatasets = circuitsData.map((circuit, index) => {
            const color = circuitColors[index % circuitColors.length];
            
            return {
                label: circuit.name,
                data: data.map((_, i) => i === index ? data[i] : null),
                borderColor: color,
                backgroundColor: color,
                borderWidth: 3,
                pointRadius: 8,
                pointHoverRadius: 10,
                pointBackgroundColor: color,
                pointBorderColor: '#fff',
                pointBorderWidth: 3,
                tension: 0.4,
                fill: false,
                showLine: false
            };
        });
        
        // Crear gr√°fica con l√≠nea base y puntos de colores
        circuitComparisonChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: labels,
                datasets: [mainDataset, ...pointDatasets]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: {
                    mode: 'point',
                    intersect: true
                },
                plugins: {
                    legend: {
                        display: true,
                        position: 'top',
                        labels: {
                            font: {
                                family: '-apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif',
                                size: 12,
                                weight: '500'
                            },
                            padding: 16,
                            usePointStyle: true,
                            pointStyle: 'circle',
                            filter: function(item, chart) {
                                return item.text !== label;
                            }
                        }
                    },
                    tooltip: {
                        backgroundColor: 'rgba(0, 0, 0, 0.8)',
                        padding: 12,
                        titleFont: {
                            size: 14,
                            weight: '600'
                        },
                        bodyFont: {
                            size: 13
                        },
                        borderColor: 'rgba(255, 255, 255, 0.2)',
                        borderWidth: 1,
                        displayColors: true,
                        callbacks: {
                            label: function(context) {
                                if (context.dataset.label === label) return null;
                                
                                let labelText = context.dataset.label || '';
                                if (labelText) {
                                    labelText += ': ';
                                }
                                labelText += context.parsed.y;
                                if (metric === 'winRate') {
                                    labelText += '%';
                                } else if (metric === 'avgPosition') {
                                    labelText += '¬∫';
                                }
                                return labelText;
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        grid: {
                            color: 'rgba(0, 0, 0, 0.05)',
                            drawBorder: false
                        },
                        title: {
                            display: true,
                            text: yAxisLabel,
                            font: {
                                size: 13,
                                weight: '600'
                            }
                        },
                        ticks: {
                            font: {
                                size: 12
                            },
                            padding: 8,
                            callback: function(value) {
                                if (metric === 'winRate') {
                                    return value + '%';
                                } else if (metric === 'avgPosition') {
                                    return value + '¬∫';
                                }
                                return value;
                            }
                        }
                    },
                    x: {
                        grid: {
                            display: false
                        },
                        ticks: {
                            font: {
                                size: 12,
                                weight: '500'
                            },
                            padding: 8
                        }
                    }
                }
            }
        });
    } else {
        // Para un solo circuito, usar gr√°fica de barras simple
        circuitComparisonChart = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: labels,
                datasets: [{
                    label: label,
                    data: data,
                    backgroundColor: circuitColors[0] + '40',
                    borderColor: circuitColors[0],
                    borderWidth: 2,
                    borderRadius: 8
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        backgroundColor: 'rgba(0, 0, 0, 0.8)',
                        padding: 12,
                        callbacks: {
                            label: function(context) {
                                let labelText = label + ': ' + context.parsed.y;
                                if (metric === 'winRate') {
                                    labelText += '%';
                                } else if (metric === 'avgPosition') {
                                    labelText += '¬∫';
                                }
                                return labelText;
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        grid: {
                            color: 'rgba(0, 0, 0, 0.05)'
                        },
                        title: {
                            display: true,
                            text: yAxisLabel
                        },
                        ticks: {
                            callback: function(value) {
                                if (metric === 'winRate') {
                                    return value + '%';
                                } else if (metric === 'avgPosition') {
                                    return value + '¬∫';
                                }
                                return value;
                            }
                        }
                    }
                }
            }
        });
    }
}

// ============================================
// DESTRUIR GR√ÅFICA
// ============================================

function destroyCircuitChart() {
    if (circuitComparisonChart) {
        circuitComparisonChart.destroy();
        circuitComparisonChart = null;
    }
}

// ============================================
// RENDERIZAR TABLA COMPARATIVA
// ============================================

function renderCircuitTable(circuitsData) {
    const tbody = document.getElementById('circuitComparisonTableBody');
    
    if (circuitsData.length === 0) {
        tbody.innerHTML = `
            <tr>
                <td colspan="7" style="text-align: center; color: #86868b; padding: 40px;">
                    No hay datos para mostrar
                </td>
            </tr>
        `;
        return;
    }
    
    tbody.innerHTML = circuitsData.map((circuit, index) => {
        const color = circuitColors[index % circuitColors.length];
        const winRateClass = circuit.winRate >= 50 ? 'positive' : circuit.winRate >= 30 ? 'neutral' : 'negative';
        const positionClass = circuit.avgPosition <= 3 ? 'positive' : circuit.avgPosition <= 8 ? 'neutral' : 'negative';
        
        return `
            <tr>
                <td>
                    <div class="circuit-name">
                        <div class="circuit-color" style="background-color: ${color};"></div>
                        ${escapeHtml(circuit.name)}
                    </div>
                </td>
                <td class="metric-value">${circuit.tournaments}</td>
                <td class="metric-value">${circuit.wins}</td>
                <td class="metric-value ${winRateClass}">${circuit.winRate.toFixed(1)}%</td>
                <td class="metric-value ${positionClass}">
                    ${circuit.avgPosition > 0 ? circuit.avgPosition.toFixed(1) + '¬∫' : '-'}
                </td>
                <td class="metric-value positive">
                    ${circuit.bestPosition > 0 ? circuit.bestPosition + '¬∫' : '-'}
                </td>
                <td>${circuit.lastDate ? new Date(circuit.lastDate).toLocaleDateString('es-ES') : '-'}</td>
            </tr>
        `;
    }).join('');
}

// ============================================
// FUNCI√ìN AUXILIAR: ESCAPE HTML
// ============================================

function escapeHtml(text) {
    if (!text) return '';
    const map = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#039;'
    };
    return String(text).replace(/[&<>"']/g, m => map[m]);
}

// ============================================
// INICIALIZAR AL CARGAR LA P√ÅGINA
// ============================================

document.addEventListener('DOMContentLoaded', () => {
    setTimeout(() => {
        if (typeof initCircuitComparison === 'function') {
            initCircuitComparison();
        }
    }, 500);
});

// Tambi√©n actualizar cuando cambien los datos
function updateCircuitComparisonIfVisible() {
    const comparisonChart = document.getElementById('circuitComparisonChart');
    if (comparisonChart && comparisonChart.offsetParent !== null) {
        initCircuitComparison();
    }
}

console.log('‚úÖ Comparativa de circuitos v3 - FIX APLICADO: Detecci√≥n mejorada de posiciones (Campe√≥n > Subcampe√≥n > Semifinales > N√∫meros)');


// ============================================
// VARIABLES GLOBALES PARA COMPARATIVA
// ============================================

let circuitComparisonChart = null;
let selectedCircuits = new Set();
const circuitColors = [
    '#3b82f6', // Azul
    '#ef4444', // Rojo
    '#10b981', // Verde
    '#f59e0b', // Amarillo
    '#8b5cf6', // P√∫rpura
    '#ec4899', // Rosa
    '#14b8a6', // Turquesa
    '#f97316', // Naranja
    '#6366f1', // √çndigo
    '#84cc16', // Lima
];

// ============================================
// FUNCI√ìN PARA OBTENER NOMBRE REAL DEL CIRCUITO
// ============================================

function getCircuitName(circuitId) {
    if (!circuitId) return 'Sin circuito';
    
    // Si es un ID (empieza con "circuit_"), buscar el nombre real
    if (circuitId.startsWith('circuit_')) {
        // Buscar en la lista de circuitos
        if (matchesData.circuits && Array.isArray(matchesData.circuits)) {
            const circuit = matchesData.circuits.find(c => c.id === circuitId);
            if (circuit && circuit.name) {
                return circuit.name;
            }
        }
        
        // Si no se encuentra, intentar obtener de los torneos
        const tournament = matchesData.tournaments.find(t => t.circuit === circuitId);
        if (tournament && tournament.circuitName) {
            return tournament.circuitName;
        }
        
        // Si a√∫n no se encuentra, retornar un nombre m√°s legible
        return circuitId.replace('circuit_', 'Circuito #').substring(0, 20);
    }
    
    // Si no es un ID, retornar tal cual (es el nombre)
    return circuitId;
}

// ============================================
// FUNCI√ìN PARA DETECTAR SI ES VICTORIA
// ============================================

function isVictory(result) {
    if (!result) return false;
    
    // Normalizar el resultado
    const normalized = String(result).trim().toLowerCase();
    
    // Casos de victoria
    const victoryPatterns = [
        '1¬∫',
        '1¬∞',
        '1',
        'primero',
        'ganador',
        'campe√≥n',
        'campeon',
        'victoria',
        'winner',
        'first'
    ];
    
    // Verificar si coincide con alg√∫n patr√≥n
    for (const pattern of victoryPatterns) {
        if (normalized === pattern || normalized === pattern.toLowerCase()) {
            return true;
        }
    }
    
    // Verificar si empieza con "1" seguido de caracteres no num√©ricos
    if (/^1[^\d]/.test(normalized)) {
        return true;
    }
    
    return false;
}

// ============================================
// FUNCI√ìN PARA EXTRAER POSICI√ìN NUM√âRICA
// ============================================

function extractPosition(result) {
    if (!result) return null;
    
    const str = String(result).trim();
    
    // Intentar extraer n√∫mero al inicio
    const match = str.match(/^(\d+)/);
    if (match) {
        return parseInt(match[1]);
    }
    
    // Casos especiales
    const specialCases = {
        'primero': 1,
        'segundo': 2,
        'tercero': 3,
        'cuarto': 4,
        'quinto': 5,
        'first': 1,
        'second': 2,
        'third': 3
    };
    
    const normalized = str.toLowerCase();
    if (specialCases[normalized]) {
        return specialCases[normalized];
    }
    
    return null;
}

// ============================================
// INICIALIZAR COMPARATIVA DE CIRCUITOS
// ============================================

function initCircuitComparison() {
    console.log('üîÑ Inicializando comparativa de circuitos...');
    
    // Obtener circuitos √∫nicos de los torneos
    const circuits = getCircuitsFromTournaments();
    
    console.log('üìä Circuitos encontrados:', circuits.length);
    
    if (circuits.length === 0) {
        document.getElementById('circuitCheckboxes').style.display = 'none';
        document.getElementById('noCircuitsMessage').style.display = 'block';
        return;
    }
    
    document.getElementById('circuitCheckboxes').style.display = 'grid';
    document.getElementById('noCircuitsMessage').style.display = 'none';
    
    // Crear checkboxes
    renderCircuitCheckboxes(circuits);
    
    // Seleccionar todos por defecto (m√°ximo 5)
    const circuitsToSelect = circuits.slice(0, 5);
    circuitsToSelect.forEach(circuit => selectedCircuits.add(circuit.id));
    
    // Actualizar UI
    updateCheckboxStates();
    
    // Renderizar gr√°fica
    updateCircuitComparison();
}

// ============================================
// OBTENER CIRCUITOS DE TORNEOS
// ============================================

function getCircuitsFromTournaments() {
    const circuitMap = new Map();
    
    matchesData.tournaments.forEach(tournament => {
        if (tournament.circuit && tournament.circuit.trim() !== '') {
            const circuitId = tournament.circuit.trim();
            const circuitName = getCircuitName(circuitId);
            
            if (!circuitMap.has(circuitId)) {
                circuitMap.set(circuitId, {
                    id: circuitId,
                    name: circuitName,
                    count: 0,
                    tournaments: []
                });
            }
            
            const circuit = circuitMap.get(circuitId);
            circuit.count++;
            circuit.tournaments.push(tournament);
        }
    });
    
    // Convertir a array y ordenar por cantidad de torneos
    return Array.from(circuitMap.values())
        .sort((a, b) => b.count - a.count);
}

// ============================================
// RENDERIZAR CHECKBOXES
// ============================================

function renderCircuitCheckboxes(circuits) {
    const container = document.getElementById('circuitCheckboxes');
    
    container.innerHTML = circuits.map((circuit, index) => `
        <div class="circuit-checkbox ${selectedCircuits.has(circuit.id) ? 'selected' : ''}" 
             onclick="toggleCircuitSelection('${escapeHtml(circuit.id)}')">
            <input 
                type="checkbox" 
                id="circuit_${index}"
                ${selectedCircuits.has(circuit.id) ? 'checked' : ''}
                onchange="toggleCircuitSelection('${escapeHtml(circuit.id)}')"
                onclick="event.stopPropagation()">
            <label for="circuit_${index}">${escapeHtml(circuit.name)}</label>
            <span class="circuit-count">${circuit.count}</span>
        </div>
    `).join('');
}

// ============================================
// TOGGLE SELECCI√ìN DE CIRCUITO
// ============================================

function toggleCircuitSelection(circuitId) {
    if (selectedCircuits.has(circuitId)) {
        selectedCircuits.delete(circuitId);
    } else {
        selectedCircuits.add(circuitId);
    }
    
    updateCheckboxStates();
    updateCircuitComparison();
}

// ============================================
// ACTUALIZAR ESTADOS DE CHECKBOXES
// ============================================

function updateCheckboxStates() {
    const circuits = getCircuitsFromTournaments();
    const checkboxes = document.querySelectorAll('.circuit-checkbox');
    
    checkboxes.forEach((checkbox, index) => {
        const circuit = circuits[index];
        if (!circuit) return;
        
        const input = checkbox.querySelector('input[type="checkbox"]');
        
        if (selectedCircuits.has(circuit.id)) {
            checkbox.classList.add('selected');
            input.checked = true;
        } else {
            checkbox.classList.remove('selected');
            input.checked = false;
        }
    });
}

// ============================================
// SELECCIONAR TODOS LOS CIRCUITOS
// ============================================

function selectAllCircuits() {
    const circuits = getCircuitsFromTournaments();
    selectedCircuits.clear();
    circuits.forEach(circuit => selectedCircuits.add(circuit.id));
    updateCheckboxStates();
    updateCircuitComparison();
}

// ============================================
// LIMPIAR SELECCI√ìN
// ============================================

function clearCircuitSelection() {
    selectedCircuits.clear();
    updateCheckboxStates();
    updateCircuitComparison();
}

// ============================================
// ACTUALIZAR COMPARATIVA
// ============================================

function updateCircuitComparison() {
    if (selectedCircuits.size === 0) {
        destroyCircuitChart();
        document.getElementById('circuitComparisonTableBody').innerHTML = `
            <tr>
                <td colspan="7" style="text-align: center; color: #86868b; padding: 40px;">
                    Selecciona al menos un circuito para ver la comparativa
                </td>
            </tr>
        `;
        return;
    }
    
    const metric = document.getElementById('comparisonMetric').value;
    const circuitsData = calculateCircuitStats();
    
    console.log('üìä Datos de circuitos calculados:', circuitsData);
    
    renderCircuitChart(circuitsData, metric);
    renderCircuitTable(circuitsData);
}

// ============================================
// CALCULAR ESTAD√çSTICAS DE CIRCUITOS
// ============================================

function calculateCircuitStats() {
    const stats = [];
    const circuits = getCircuitsFromTournaments();
    
    selectedCircuits.forEach(circuitId => {
        const circuit = circuits.find(c => c.id === circuitId);
        if (!circuit) return;
        
        const tournaments = matchesData.tournaments.filter(t => t.circuit === circuitId);
        
        if (tournaments.length === 0) return;
        
        // Calcular estad√≠sticas
        const totalTournaments = tournaments.length;
        
        // Contar victorias con la nueva funci√≥n mejorada
        const totalWins = tournaments.filter(t => isVictory(t.result)).length;
        
        console.log(`üèÜ ${circuit.name}: ${totalWins} victorias de ${totalTournaments} torneos`);
        
        const winRate = totalTournaments > 0 ? (totalWins / totalTournaments * 100) : 0;
        
        // Calcular total de partidas
        let totalMatches = 0;
        let totalMatchWins = 0;
        
        tournaments.forEach(t => {
            if (t.stats) {
                // Intentar diferentes nombres de campos
                const wins = t.stats.victorias || t.stats.wins || t.stats.gamesWon || 0;
                const losses = t.stats.derrotas || t.stats.losses || t.stats.gamesLost || 0;
                
                totalMatches += wins + losses;
                totalMatchWins += wins;
            }
        });
        
        // Calcular posici√≥n promedio
        const positions = tournaments
            .map(t => extractPosition(t.result))
            .filter(p => p !== null && p > 0);
        
        const avgPosition = positions.length > 0 
            ? positions.reduce((a, b) => a + b, 0) / positions.length 
            : 0;
        
        const bestPosition = positions.length > 0 ? Math.min(...positions) : 0;
        
        // √öltima participaci√≥n
        const sortedTournaments = tournaments.sort((a, b) => new Date(b.date) - new Date(a.date));
        const lastDate = sortedTournaments[0]?.date || '';
        
        const circuitStats = {
            id: circuitId,
            name: circuit.name,
            tournaments: totalTournaments,
            wins: totalWins,
            winRate: winRate,
            avgPosition: avgPosition,
            bestPosition: bestPosition,
            totalMatches: totalMatches,
            totalMatchWins: totalMatchWins,
            lastDate: lastDate
        };
        
        console.log('üìä Estad√≠sticas calculadas:', circuitStats);
        
        stats.push(circuitStats);
    });
    
    return stats;
}

// ============================================
// RENDERIZAR GR√ÅFICA DE CIRCUITOS (L√çNEAS)
// ============================================

function renderCircuitChart(circuitsData, metric) {
    const ctx = document.getElementById('circuitComparisonChart');
    
    if (!ctx) {
        console.error('Canvas no encontrado');
        return;
    }
    
    // Destruir gr√°fica anterior
    destroyCircuitChart();
    
    // Preparar datos seg√∫n la m√©trica
    let labels = circuitsData.map(c => c.name);
    let data, label, yAxisLabel;
    
    switch(metric) {
        case 'tournaments':
            data = circuitsData.map(c => c.tournaments);
            label = 'N√∫mero de Torneos';
            yAxisLabel = 'Torneos';
            break;
        case 'winRate':
            data = circuitsData.map(c => parseFloat(c.winRate.toFixed(1)));
            label = 'Tasa de Victoria (%)';
            yAxisLabel = 'Porcentaje (%)';
            break;
        case 'avgPosition':
            data = circuitsData.map(c => c.avgPosition > 0 ? parseFloat(c.avgPosition.toFixed(1)) : 0);
            label = 'Posici√≥n Promedio';
            yAxisLabel = 'Posici√≥n';
            break;
        case 'totalMatches':
            data = circuitsData.map(c => c.totalMatches);
            label = 'Total de Partidas';
            yAxisLabel = 'Partidas';
            break;
        case 'totalWins':
            data = circuitsData.map(c => c.wins);
            label = 'Total de Victorias';
            yAxisLabel = 'Victorias en Torneos';
            break;
        default:
            data = circuitsData.map(c => c.tournaments);
            label = 'N√∫mero de Torneos';
            yAxisLabel = 'Torneos';
    }
    
    console.log('üìä Renderizando gr√°fica:', { metric, label, data });
    
    // Si hay m√∫ltiples circuitos, crear l√≠nea conectada
    if (circuitsData.length > 1) {
        // Crear una sola l√≠nea que conecta todos los puntos
        const mainDataset = {
            label: label,
            data: data,
            borderColor: '#94a3b8',
            backgroundColor: 'transparent',
            borderWidth: 2,
            borderDash: [5, 5],
            pointRadius: 0,
            tension: 0.4,
            fill: false
        };
        
        // Crear puntos individuales de colores
        const pointDatasets = circuitsData.map((circuit, index) => {
            const color = circuitColors[index % circuitColors.length];
            
            return {
                label: circuit.name,
                data: data.map((_, i) => i === index ? data[i] : null),
                borderColor: color,
                backgroundColor: color,
                borderWidth: 3,
                pointRadius: 8,
                pointHoverRadius: 10,
                pointBackgroundColor: color,
                pointBorderColor: '#fff',
                pointBorderWidth: 3,
                tension: 0.4,
                fill: false,
                showLine: false
            };
        });
        
        // Crear gr√°fica con l√≠nea base y puntos de colores
        circuitComparisonChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: labels,
                datasets: [mainDataset, ...pointDatasets]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: {
                    mode: 'point',
                    intersect: true
                },
                plugins: {
                    legend: {
                        display: true,
                        position: 'top',
                        labels: {
                            font: {
                                family: '-apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif',
                                size: 12,
                                weight: '500'
                            },
                            padding: 16,
                            usePointStyle: true,
                            pointStyle: 'circle',
                            filter: function(item, chart) {
                                return item.text !== label;
                            }
                        }
                    },
                    tooltip: {
                        backgroundColor: 'rgba(0, 0, 0, 0.8)',
                        padding: 12,
                        titleFont: {
                            size: 14,
                            weight: '600'
                        },
                        bodyFont: {
                            size: 13
                        },
                        borderColor: 'rgba(255, 255, 255, 0.2)',
                        borderWidth: 1,
                        displayColors: true,
                        callbacks: {
                            label: function(context) {
                                if (context.dataset.label === label) return null;
                                
                                let labelText = context.dataset.label || '';
                                if (labelText) {
                                    labelText += ': ';
                                }
                                labelText += context.parsed.y;
                                if (metric === 'winRate') {
                                    labelText += '%';
                                } else if (metric === 'avgPosition') {
                                    labelText += '¬∫';
                                }
                                return labelText;
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        grid: {
                            color: 'rgba(0, 0, 0, 0.05)',
                            drawBorder: false
                        },
                        title: {
                            display: true,
                            text: yAxisLabel,
                            font: {
                                size: 13,
                                weight: '600'
                            }
                        },
                        ticks: {
                            font: {
                                size: 12
                            },
                            padding: 8,
                            callback: function(value) {
                                if (metric === 'winRate') {
                                    return value + '%';
                                } else if (metric === 'avgPosition') {
                                    return value + '¬∫';
                                }
                                return value;
                            }
                        }
                    },
                    x: {
                        grid: {
                            display: false
                        },
                        ticks: {
                            font: {
                                size: 12,
                                weight: '500'
                            },
                            padding: 8
                        }
                    }
                }
            }
        });
    } else {
        // Para un solo circuito, usar gr√°fica de barras simple
        circuitComparisonChart = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: labels,
                datasets: [{
                    label: label,
                    data: data,
                    backgroundColor: circuitColors[0] + '40',
                    borderColor: circuitColors[0],
                    borderWidth: 2,
                    borderRadius: 8
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        backgroundColor: 'rgba(0, 0, 0, 0.8)',
                        padding: 12,
                        callbacks: {
                            label: function(context) {
                                let labelText = label + ': ' + context.parsed.y;
                                if (metric === 'winRate') {
                                    labelText += '%';
                                } else if (metric === 'avgPosition') {
                                    labelText += '¬∫';
                                }
                                return labelText;
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        grid: {
                            color: 'rgba(0, 0, 0, 0.05)'
                        },
                        title: {
                            display: true,
                            text: yAxisLabel
                        },
                        ticks: {
                            callback: function(value) {
                                if (metric === 'winRate') {
                                    return value + '%';
                                } else if (metric === 'avgPosition') {
                                    return value + '¬∫';
                                }
                                return value;
                            }
                        }
                    }
                }
            }
        });
    }
}

// ============================================
// DESTRUIR GR√ÅFICA
// ============================================

function destroyCircuitChart() {
    if (circuitComparisonChart) {
        circuitComparisonChart.destroy();
        circuitComparisonChart = null;
    }
}

// ============================================
// RENDERIZAR TABLA COMPARATIVA
// ============================================

function renderCircuitTable(circuitsData) {
    const tbody = document.getElementById('circuitComparisonTableBody');
    
    if (circuitsData.length === 0) {
        tbody.innerHTML = `
            <tr>
                <td colspan="7" style="text-align: center; color: #86868b; padding: 40px;">
                    No hay datos para mostrar
                </td>
            </tr>
        `;
        return;
    }
    
    tbody.innerHTML = circuitsData.map((circuit, index) => {
        const color = circuitColors[index % circuitColors.length];
        const winRateClass = circuit.winRate >= 50 ? 'positive' : circuit.winRate >= 30 ? 'neutral' : 'negative';
        const positionClass = circuit.avgPosition <= 3 ? 'positive' : circuit.avgPosition <= 8 ? 'neutral' : 'negative';
        
        return `
            <tr>
                <td>
                    <div class="circuit-name">
                        <div class="circuit-color" style="background-color: ${color};"></div>
                        ${escapeHtml(circuit.name)}
                    </div>
                </td>
                <td class="metric-value">${circuit.tournaments}</td>
                <td class="metric-value">${circuit.wins}</td>
                <td class="metric-value ${winRateClass}">${circuit.winRate.toFixed(1)}%</td>
                <td class="metric-value ${positionClass}">
                    ${circuit.avgPosition > 0 ? circuit.avgPosition.toFixed(1) + '¬∫' : '-'}
                </td>
                <td class="metric-value positive">
                    ${circuit.bestPosition > 0 ? circuit.bestPosition + '¬∫' : '-'}
                </td>
                <td>${circuit.lastDate ? new Date(circuit.lastDate).toLocaleDateString('es-ES') : '-'}</td>
            </tr>
        `;
    }).join('');
}

// ============================================
// FUNCI√ìN AUXILIAR: ESCAPE HTML
// ============================================

function escapeHtml(text) {
    if (!text) return '';
    const map = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#039;'
    };
    return String(text).replace(/[&<>"']/g, m => map[m]);
}

// ============================================
// INICIALIZAR AL CARGAR LA P√ÅGINA
// ============================================

document.addEventListener('DOMContentLoaded', () => {
    setTimeout(() => {
        if (typeof initCircuitComparison === 'function') {
            initCircuitComparison();
        }
    }, 500);
});

// Tambi√©n actualizar cuando cambien los datos
function updateCircuitComparisonIfVisible() {
    const comparisonChart = document.getElementById('circuitComparisonChart');
    if (comparisonChart && comparisonChart.offsetParent !== null) {
        initCircuitComparison();
    }
}

console.log('‚úÖ Comparativa de circuitos v2 cargada (victorias mejoradas + todas las m√©tricas)');
</script>
